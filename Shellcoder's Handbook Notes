# CHAPTER 1:
  * Intruction and Data:
  A modern computer makes no real distinction between instructions and data. We can feed instructions while it is expecting data.
  This characteristic makes system exploitation possible.
  * What happens when a program is execuated?
  First, the OS creates an address space in which the program can run. Next, information is loaded from the program's
  executable file to that space. There are 3 types of segments:
    - .text: is mapped as read-only holding the program instructions
    - .bss: is writable containing uninitialized data
    - .data: is writable containing static initialized data
  Finally, the stack and heap are initialized
    - Stack: 
     + Last In First Out (LIFO) data structure
     + Stores local variables, info ralating to functions call and other info used to clean up the stack after a function is called
     + Grows down 
    - Heap:
     + First In First Out (FIFO) data structure
     + Holds dynamic variables
     + Grows up
  * Registers:
   - ESP (stack pointer) points to the last address used by the stack
   - EIP (instruction pointer) contains the address of the next machine instruction to be executed. 
   - EBP (frame pointer) used to calculated an address relative to another address. 
   * GOAL: TO ACCESS AND CHANGE THE VALUE STORED IN THE EIP REGISTER *
# CHAPTER 2: 
 * Buffer: limited and contiguously allocated set of memory. The most common buffer in C is an array
 * How a function inside main function works with the stack:
  1. When the program executed, main is called, a stack frame for main is created on the stack. Stack pointer points to the top of the 
  stack frame
  2. Push the arguments for the function onto the stack.
  3. When the arguments are places on the stack, the function is called, placing the RET onto the stack. Now stack poniter points to 
  the location RET stored.
  4. Stack frame for the function is created. Before any instructions of the function can be executed, the prolog is executed. 
  The prolog does a few things:
         - Push current EBP (of main function) onto the stack
         - Copy the current ESP into EBP
         - Create space on the stack for function's local variables
  Now, stack pointer points to the top of function's stack frame
  5. Frame pointer is added pointing to location where the stack pointer was (location RET stored)
  6. When the function has completed, function's stack frame is popped off the stack, stack pointer set back to where frame pointer is
  7. Return the execution to where RET value is. Execution is back to main
  8. Pop RET and arguments off the stack
  
