# Bomb Lab ( Hai Dang )

A binary bomb is a program that consists of a sequence of phases. Each phase expects you to type a particular string on stdin. If you type the correct string, then the phase is defused and the bomb proceeds to the next phase. Otherwise, the bomb explodes by printing "BOOM!!!" and then terminating. The bomb is defused when every phase has been defused. You must "defuse" their own unique bomb by disassembling and reverse engineering the program to determine what the 6 strings should be. You need to understand assembly language, and also learn how to use a debugger. It's also great fun.

## Start:

To avoid accidentally detonating the bomb, we will need to learn how to single-step through the assembly code and how to set breakpoints. 
we will also need to learn how to inspect both the registers and the memory states. Type command : 

```
danghai@ubuntu:~/Bomb_lab$ gdb bomb
(gdb) break phase_1
(gdb) run
Starting program: /home/danghai/Bomb_lab/bomb 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
test
Breakpoint 1, 0x0000000000400ee0 in phase_1 ()
(gdb) disas
```

Obviously, we should set breakpoint at phase_1 and analyze the code. After typing running the code, they ask string to defuse the bomb; and then I insert `test` string
I want to disas to see the assembly code for `phase_1` function to find the `string` for defusing bomb

Assembly code:

```asm
Dump of assembler code for function phase_1:
=> 0x0000000000400ee0 <+0>:	sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:	mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:	callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:	test   %eax,%eax
   0x0000000000400ef0 <+16>:	je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:	callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:	add    $0x8,%rsp
   0x0000000000400efb <+27>:	retq   
End of assembler dump.
```

We can realize that before call the function `explode_bomb` at address `0x400ef2`, they call function `strings_not_equal` at address `0x401338`. 
Therefore, we need to analyze the code function at this address. Now, quitting gdb and set the breakpoint at `0x401338`. 

Assembly code:

```asm
=> 0x0000000000401338 <+0>:	push   %r12
   0x000000000040133a <+2>:	push   %rbp
   0x000000000040133b <+3>:	push   %rbx
   0x000000000040133c <+4>:	mov    %rdi,%rbx
   0x000000000040133f <+7>:	mov    %rsi,%rbp
   0x0000000000401342 <+10>:	callq  0x40131b <string_length>
   0x0000000000401347 <+15>:	mov    %eax,%r12d
   0x000000000040134a <+18>:	mov    %rbp,%rdi
   0x000000000040134d <+21>:	callq  0x40131b <string_length>
   0x0000000000401352 <+26>:	mov    $0x1,%edx
   0x0000000000401357 <+31>:	cmp    %eax,%r12d
   0x000000000040135a <+34>:	jne    0x40139b <strings_not_equal+99>
   0x000000000040135c <+36>:	movzbl (%rbx),%eax
   0x000000000040135f <+39>:	test   %al,%al
   0x0000000000401361 <+41>:	je     0x401388 <strings_not_equal+80>
   0x0000000000401363 <+43>:	cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:	je     0x401372 <strings_not_equal+58>
   0x0000000000401368 <+48>:	jmp    0x40138f <strings_not_equal+87>
   0x000000000040136a <+50>:	cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:	nopl   (%rax)
   0x0000000000401370 <+56>:	jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:	add    $0x1,%rbx
   0x0000000000401376 <+62>:	add    $0x1,%rbp
   0x000000000040137a <+66>:	movzbl (%rbx),%eax
   0x000000000040137d <+69>:	test   %al,%al
   0x000000000040137f <+71>:	jne    0x40136a <strings_not_equal+50>
   0x0000000000401381 <+73>:	mov    $0x0,%edx
   0x0000000000401386 <+78>:	jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:	mov    $0x0,%edx
   0x000000000040138d <+85>:	jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:	mov    $0x1,%edx
   0x0000000000401394 <+92>:	jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:	mov    $0x1,%edx
   0x000000000040139b <+99>:	mov    %edx,%eax
   0x000000000040139d <+101>:	pop    %rbx
   0x000000000040139e <+102>:	pop    %rbp
   0x000000000040139f <+103>:	pop    %r12
   0x00000000004013a1 <+105>:	retq   
```

After pushing 3 registers `%r12, %rbp, %rbx` into stack, we can see they move data: 
```asm
   0x000000000040133c <+4>:	mov    %rdi,%rbx
   0x000000000040133f <+7>:	mov    %rsi,%rbp
```

As we know, registers `%rdi and %rsi` use for callee-save register. We can think it will store the string for defusing the bomb. 
If we are not sure about that, we can set the breakpoint at `0x401357` because it compares these value and jump to another label
after call function `string_length`. I think it will calculate and compare the `input` string with `defuse` string. Now, quitting
gdb and set the breakpoint at address `0x401357`. I still use the old input string with `test`. After disassembly, I want to see
the value at `%eax and %r12d` by command:

```
(gdb) print /d $eax
$1 = 52
(gdb) print /d $r12d
$2 = 4
```

Wow! It is very make sense because input string `test` having 4 character. Therefore, we know that the defuse string is 52 character. 
However, the goal is identifying the defuse string. I will set the breakpoint at address `0x40133f` before calling function string_length
I want to see the value register `%rdi`
```
(gdb) print /x $rdi
$2 = 0x603780
(gdb) x/10x $rdi
```

Memory:
```asm
0x603780 <input_strings>:	0x74736574	0x00000000	0x00000000	0x00000000
0x603790 <input_strings+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x6037a0 <input_strings+32>:	0x00000000	0x00000000
```

Nice! we can see `0x74736574` represents `test` string. Because it is stored by Little Endian. `0x74736574` --> `74 65 73 74`. 
According to the [ASCII table](http://www.asciitable.com/). `74 65 73 74` = `test`. Or we can do the better way by command 

```
(gdb) x/1s $rdi
0x603780 <input_strings>:	"test"
```

Now, I want to the value at register `%rsi`. 

```
(gdb) print /x $rsi
$4 = 0x402400
```

And the defuse string: 

```
(gdb) x/3s $rsi
0x402400:	"Border relations with Canada have never been better."
0x402435:	""
0x402436:	""
```

Run the code and see we can defuse the phase_1 bomb. 

```
danghai@ubuntu:~/Bomb_lab$ ./bomb
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
```

Similarly, applying the same previous technique, we can defuse 6 phases bomb. I store these strings at file defuse_bomb.txt

```
Border relations with Canada have never been better.
1 2 4 8 16 32
0 207
7 0
ionefg
4 3 2 1 6 5
```

DONE! Run the code and see the result: 

```
danghai@ubuntu:~/Bomb_lab$ ./bomb defuse_bomb.txt 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Congratulations! You've defused the bomb!
```



