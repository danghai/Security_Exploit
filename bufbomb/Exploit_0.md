# Level 0: Candle
The BUFBOMB program reads a string from standard input. It does so with the function `getbuf`
overrunning the buffer typically causes the program state to be corrupted leading to a memory 
access error. By exploiting this vulnerable memory, we can attack the file to get information 
In particular, in this level, we will exploit and make program run the function `smoke` when
`getbuf` executes its return statement.

Method: providing a enough long string to make getbuf overflow. And then, we can take
control execute program by putting return address on stack memory on EAX register 

## Start: 

1. At the beginning, getting assembly code from execute bufbomb file, and create id cookie
following command:

```
objdump -d bufbomb > assembly.txt
danghai@babbage:~/buflab-handout$ ./makecookie danghai
0x2b9b4cfd
danghai@babbage:~/buflab-handout$ 
```

2. Finding the address function `smoke` in BUFBOMB assembly 
```
danghai@babbage:~/buflab-handout$ grep -i "smoke" assembly.txt
08048cea <smoke>:
```
The address for `smoke` function = `08048cea`

3. Calculating the length of the string size of stack memory
```
danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break getbuf
(gdb) run -u danghai
(gdb) break *getbuf+17
(gdb) disas

```

Result:
```asm
(gdb) disas
Dump of assembler code for function getbuf:
   0x080490ce <+0>:	push   %ebp
   0x080490cf <+1>:	mov    %esp,%ebp
   0x080490d1 <+3>:	sub    $0x38,%esp
=> 0x080490d4 <+6>:	lea    -0x28(%ebp),%eax
   0x080490d7 <+9>:	mov    %eax,(%esp)
   0x080490da <+12>:	call   0x8048b4a <Gets>
   0x080490df <+17>:	mov    $0x1,%eax
   0x080490e4 <+22>:	leave  
   0x080490e5 <+23>:	ret    
End of assembler dump.
```
Arrow indicating breakpoint when setting at `getbuf` function. The goal is to push the string
onto stack memory locating `%ebp`. It means that we need to know the address of `%ebp`
```
(gdb) info registers
```

Result:
```asm
(gdb) info registers
eax            0x3d057629	1023768105
ecx            0x3d057629	1023768105
edx            0xf7fa03e4	-134609948
ebx            0x0	0
esp            0x55683098	0x55683098 <_reserved+1036440>
ebp            0x556830d0	0x556830d0 <_reserved+1036496>
esi            0x55686420	1432904736
edi            0xee0	3808
eip            0x80490d4	0x80490d4 <getbuf+6>
eflags         0x212	[ AF IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
```
